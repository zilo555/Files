// Copyright (c) Files Community
// Licensed under the MIT License.

namespace Files.Core.SourceGenerator.Generators
{
	[Generator(LanguageNames.CSharp)]
	internal sealed class CommandManagerGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var sources = context.SyntaxProvider.ForAttributeWithMetadataName(
				"Files.Shared.Attributes.GeneratedRichCommandAttribute",
				static (node, token) => true,
				static (context, token) =>
				{
					var typeSymbol = (INamedTypeSymbol)context.TargetSymbol;
					var commandName = typeSymbol.Name;

					if (typeSymbol.Name.EndsWith("Action"))
						commandName = typeSymbol.Name[..^"Action".Length];

					return commandName;
				})
				.Collect()
				.Select((commandNames, token) => commandNames.Sort());

			context.RegisterSourceOutput(sources, static (context, commandNames) =>
			{
				if (commandNames.Length is 0)
					return;

				string commandCodesEnum = GenerateCommandCodes(commandNames);
				context.AddSource($"CommandCodes.g.cs", commandCodesEnum);

				string commandManagerInterface = GenerateICommandManager(commandNames);
				context.AddSource($"ICommandManager.g.cs", commandManagerInterface);

				string commandManagerClass = GenerateCommandManager(commandNames);
				context.AddSource($"CommandManager.g.cs", commandManagerClass);
			});
		}

		private static string GenerateCommandCodes(ImmutableArray<string> commandNames)
		{
			StringBuilder builder = new(4096);
			builder.Append("""
				// <auto-generated/>
				
				namespace Files.App.Data.Commands;
				
				public enum CommandCodes
				{
					None,
				
				""");

			foreach (var commandName in commandNames)
				builder.AppendLine($"	{commandName},");

			builder.Append("""
				}

				""");

			return builder.ToString();
		}

		private static string GenerateICommandManager(ImmutableArray<string> commandNames)
		{
			StringBuilder builder = new(8192);
			builder.Append("""
				// <auto-generated/>
				
				namespace Files.App.Data.Commands;
				
				public interface ICommandManager : IEnumerable<IRichCommand>
				{
					IRichCommand this[CommandCodes code] { get; }
					IRichCommand this[string code] { get; }
					IRichCommand this[HotKey customHotKey] { get; }
				
					IRichCommand None { get; }
				
				""");

			foreach (var commandName in commandNames)
				builder.AppendLine($"	IRichCommand {commandName} {{ get; }}");


			builder.Append("""
				}

				""");

			return builder.ToString();
		}

		private static string GenerateCommandManager(ImmutableArray<string> commandNames)
		{
			StringBuilder builder = new(32768);
			builder.Append("""
				// <auto-generated/>
				
				using global::Files.App.Actions;
				using global::System.Collections.Immutable;
				
				namespace Files.App.Data.Commands;
				
				internal sealed partial class CommandManager
				{
					public IRichCommand None => this[CommandCodes.None];
				
				""");

			foreach (var commandName in commandNames)
				builder.AppendLine($"	public IRichCommand {commandName} => this[CommandCodes.{commandName}];");

			builder.Append("""
				
					private static ImmutableArray<IRichCommand> CreateCommands() =>
					[
						new NoneCommand(),

				""");

			foreach (var commandName in commandNames)
				builder.AppendLine($"		new ActionCommand(CommandCodes.{commandName}, new {commandName}Action()),");

			builder.Append("""
					];
				}

				""");

			return builder.ToString();
		}
	}
}
